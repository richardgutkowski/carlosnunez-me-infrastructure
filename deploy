#!/usr/bin/env bash
set -e

SUPPORTED_ENVIRONMENTS=$(find config -type f -name "infrastructure_config*" \
  -exec sh -c "echo {} | cut -f2 -d '.'" \;)

usage() {
  printf "deploy.sh [target_environment]\n"
  printf "Deploys infrastructure for carlosnunez.me\n\n"
  printf "  target_environment: The environment to deploy onto. \
Supported environments: [${SUPPORTED_ENVIRONMENTS}]\n\n"
}

is_env_supported() {
  env_to_check="$1"
  supported_envs="$2"
  matching_envs_found=$(echo "$supported_envs" | grep "${env_to_check}")
  if [ "$matching_envs_found" != "" ]
  then
    return 0
  else
    return 1
  fi
}

NUMBER_OF_ARGS_EXPECTED=1
if [ "$#" != "$NUMBER_OF_ARGS_EXPECTED" ]
then
  usage
  exit 1
fi

target_env=$1
if ! is_env_supported $target_env $SUPPORTED_ENVIRONMENTS
then
  printf "ERROR: '${target_env}' not found in '${SUPPORTED_ENVIRONMENTS}'\n"
  exit 1
fi

# Create a list of the env vars to provide to our deployment job.
# NOTE: Our Rakefile will check whether these are empty or not.
echo "AWS_REGION=$AWS_REGION\n\
AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID\n\
AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY\n\
TARGET_ENVIRONMENT=$target_env" > .docker_env_vars

# Do the deployment! Ignore errors after this point so that we can always ensure
# we have a clean image.
docker build -t "jenkins_local_ci"
docker run --detach \
  --env-file .docker_env_vars \
  --name infrastructure_deployment_$target_env \
  --publish 8080:8080 \
  --publish 5000:5000 \
  --rm \
  --volume $PWD/config/jenkins/jenkins_home:/var/jenkins_home \
  jenkins_local_ci || true

# Cleanup.
rm .docker_env_vars
